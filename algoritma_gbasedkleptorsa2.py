# -*- coding: utf-8 -*-
"""Algoritma gBasedKleptoRSA2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xhP5G5nuUDVSRj0oTVkuoI5_cirxeVuR
"""

import random
import time
import sympy
import pandas as pd
from math import isqrt

"""##Pembangkitan Basis Parameter"""

def generate_Rx_y():
    # Inisialisasi matriks Rx_y dengan nilai awal
    Rx_y = [[(0, 0) for _ in range(9)] for _ in range(9)]

    # Mengisi matriks Rx_y dengan nilai yang diurutkan
    current_ash = -4
    current_bsh = -4
    for i in range(9):
        for j in range(9):
            Rx_y[i][j] = (current_ash, current_bsh)
            current_bsh += 1
            if current_bsh > 4:
                current_bsh = -4
                current_ash += 1

    # Memastikan nilai-nilai berbeda dalam setiap baris dan kolom
    for i in range(9):
        for j in range(9):
            while Rx_y[i][j] in Rx_y[i][:j] + Rx_y[i][j+1:]:
                # Jika nilai sudah ada, geser ke nilai selanjutnya
                current_bsh += 1
                if current_bsh > 4:
                    current_bsh = -4
                    current_ash += 1
                Rx_y[i][j] = (current_ash, current_bsh)

            # Pastikan nilai berbeda dalam kolom yang sama
            for k in range(i):
                while Rx_y[i][j] in (Rx_y[l][j] for l in range(k)):
                    # Jika nilai sudah ada, geser ke nilai selanjutnya
                    current_bsh += 1
                    if current_bsh > 4:
                        current_bsh = -4
                        current_ash += 1
                    Rx_y[i][j] = (current_ash, current_bsh)

    return Rx_y

Rx_y = generate_Rx_y()
print(Rx_y)

def random_big_integer(bits):
    return random.getrandbits(bits)

def random_range(start, end):
    return random.randint(start, end)

def dec_to_bin(y):
    return format(y, 'b')

def generate_S(l, Rx_y):
    start_time = time.time()
    S = [[0 for _ in range(2)] for _ in range(81)]
    K = random_big_integer(l - 63)
    a = random_big_integer(l)
    b = random_big_integer(l)
    while abs(len(dec_to_bin(a))-len(dec_to_bin(b))) > 4:
      a = random_big_integer(l)
      b = random_big_integer(l)
    S[0] = [a,b]

    for i in range(1, 81):
        Dsh = random_range(32, 54)
        Z = K << Dsh
        x = i // 9
        y = i % 9
        ash, bsh = Rx_y[x][y]

        if ash >= 0:
            S[i][0] = (a << ash) + Z
        else:
            S[i][0] = (a >> -ash) + Z

        if bsh >= 0:
            S[i][1] = (b << bsh) + Z
        else:
            S[i][1] = (b >> -bsh) + Z

    Du = random_range(2**16, 2**32)
    end_time = time.time()
    return S, Du, end_time - start_time

# Contoh Penggunaan
S, Du, exec_time = generate_S(126, Rx_y)
print("S matrix:", S)
print("Du:", Du)
print("Execution Time:", exec_time)

"""##Pembangkitan Domain Kunci RSA"""

def fpb(a, b):
    """Menghitung Faktor Persekutuan Terbesar (FPB) dari dua bilangan."""
    while b:
        a, b = b, a % b
    return abs(a)

def modinv(a, m):
    """Menghitung invers modulo a^(-1) mod m dengan menggunakan algoritma Extended Euclidean."""
    if fpb(a,m)==1:
      m0, x0, x1 = m, 0, 1
      while a > 1:
          q = a // m
          m, a = a % m, m
          x0, x1 = x1 - q * x0, x0
      return x1 + m0 if x1 < 0 else x1
    else:
      print(f"{a} tidak relatif prima dengan {m}!")

def Ga(id, time):
    # Fungsi placeholder Ga untuk menghasilkan nilai da
    da = hash((id, time, "Ga")) % 103
    if da == 0:
      return 103
    else:
      return da

def Gb(id, time):
    # Fungsi placeholder Gb untuk menghasilkan nilai db
    db = hash((id, time, "Gb")) % 103
    if db == 0:
      return 103
    else:
      return db

def is_probable_prime(n, k=8):
    # Algoritma Miller-Rabin dengan banyak iterasi k=8 untuk mengecek keprimaan suatu bilangan
    if n == 2 or n == 3:
        return True
    if n % 2 == 0 or n == 1:
        return False

    r, s = 0, n - 1
    while s % 2 == 0:
        r += 1
        s //= 2

    for _ in range(k):
        a = random.randint(2, n - 2)
        x = pow(a, s, n)
        if x == 1 or x == n - 1:
            continue
        for _ in range(r - 1):
            x = pow(x, 2, n)
            if x == n - 1:
                break
        else:
            return False

    return True

def NextPrime(x):
    x = x + 1 if x % 2 == 0 else x + 2
    while True:
        if is_probable_prime(x):
            return x
        x += 2

def generate_keys(k, S, Du, e, da, db):
    start_time = time.time()
    l = len(dec_to_bin(S[0][1]))   # Bitsize of S[0][1]
    u = random_big_integer((k // 2) - l)
    m = random_range(0, 80)

    p, q = 0, 0

    for i in range(81):
        f = (m + i) % 81
        d = (u - Du) * (u + Du) * S[f][0] * S[f][1]

        if len(dec_to_bin(d)) == k:
            rr_a = random_range(1, 171)
            Da = rr_a << da
            p = NextPrime((u - Du) * (S[f][0] + Da))
            rr_b = random_range(1, 171)
            Db = rr_b << db
            q = NextPrime((u + Du) * (S[f][1] + Db))

            if p < q:
              p, q = q, p

            if fpb(e, (p - 1) * (q - 1)) == 1:
              break

    N = p * q
    d = modinv(e, (p - 1) * (q - 1))
    end_time = time.time()

    return (N,e), (p, q, d), end_time - start_time

# Contoh Penggunaan
e = 65537
id_cert = "sample_id"
start_date = "2024-05-10"
da = Ga(id_cert, start_date)
db = Gb(id_cert, start_date)

public_key, private_key, execution_time = generate_keys(1024, S, Du, e, da, db)
print("Ukuran Kunci:", 1024, "bit")
print("Kunci Publik (n, e):", public_key)
print("Kunci Privat (p, q, d):", private_key)
print("Waktu Eksekusi:", execution_time, "detik")

"""## Faktorisasi Kunci RSA"""

def factor_keys(S, N, e, da, db):
    start_time = time.time()
    for index in range(81):
        for wL in range(1, 172):
            aV = S[index][0] + (wL << da)

            for wH in range(1, 172):
                bV = S[index][1] + (wH << db)
                n = aV * bV
                M = n * N
                t = isqrt(M)
                z = (t+1)**2 - M
                i = isqrt(z)

                if i**2 == z:
                    f = t - i + 1
                    q = fpb(f, N)
                    p = N // q
                    d = modinv(e, (p - 1) * (q - 1))
                    end_time = time.time()
                    return p, q, d, end_time-start_time
    end_time = time.time()
    return 0, 0, 0, end_time-start_time

p, q, d, execution_time = factor_keys(S, public_key[0], public_key[1], da, db)
print("Prima p dan q untuk ukuran ", 1024, " bit :", (p,q))
print("Waktu Eksekusi:", execution_time, "detik")

